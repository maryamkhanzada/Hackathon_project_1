# Python Integration with ROS 2 (rclpy)

**rclpy** is the Python client library for ROS 2. It provides a Pythonic interface to create nodes, publish/subscribe to topics, call services, and use actions. This section covers everything you need to write ROS 2 applications in Python.

## Why Python for ROS 2?

**Advantages of Python**:
- ✅ Rapid prototyping and development
- ✅ Extensive libraries for AI/ML (NumPy, TensorFlow, PyTorch)
- ✅ Easy integration with vision libraries (OpenCV, PIL)
- ✅ Simpler syntax than C++ for beginners
- ✅ Great for high-level logic and coordination

**When to use C++ instead**:
- Real-time control loops (< 1ms cycles)
- Performance-critical perception pipelines
- Low-level hardware drivers
- Memory-constrained embedded systems

For humanoid robotics, **hybrid approaches** work best: C++ for low-level control, Python for high-level planning and AI integration[^1].

## Setting Up rclpy

### Installation

```bash
# rclpy comes with ROS 2 installation
sudo apt install ros-humble-rclpy

# Verify installation
python3 -c "import rclpy; print(rclpy.__version__)"
```

### Project Structure

```
my_robot_ws/
├── src/
│   └── my_robot_pkg/
│       ├── my_robot_pkg/
│       │   ├── __init__.py
│       │   ├── my_node.py
│       │   └── utils.py
│       ├── package.xml
│       ├── setup.py
│       ├── setup.cfg
│       └── resource/my_robot_pkg
├── install/
├── build/
└── log/
```

## Creating Your First ROS 2 Node

### Minimal Node Example

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Minimal node has been started')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Key components**:
- `rclpy.init()`: Initialize ROS 2 communications
- `Node('node_name')`: Create a node with a name
- `rclpy.spin()`: Process callbacks (blocking)
- `destroy_node()` / `shutdown()`: Cleanup

## Publishers and Subscribers

### Publisher Example

```python
from rclpy.node import Node
from std_msgs.msg import String

class PublisherNode(Node):
    def __init__(self):
        super().__init__('publisher_node')
        self.publisher = self.create_publisher(String, 'topic_name', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.count = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.count}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Published: "{msg.data}"')
        self.count += 1
```

**Parameters**:
- `String`: Message type
- `'topic_name'`: Topic to publish to
- `10`: Queue size (QoS history depth)

### Subscriber Example

```python
from rclpy.node import Node
from std_msgs.msg import String

class SubscriberNode(Node):
    def __init__(self):
        super().__init__('subscriber_node')
        self.subscription = self.create_subscription(
            String,
            'topic_name',
            self.listener_callback,
            10
        )

    def listener_callback(self, msg):
        self.get_logger().info(f'Received: "{msg.data}"')
```

### Humanoid Robot Example: Joint States

```python
from sensor_msgs.msg import JointState

class JointStatePublisher(Node):
    def __init__(self):
        super().__init__('joint_state_publisher')
        self.publisher = self.create_publisher(JointState, '/joint_states', 10)
        self.timer = self.create_timer(0.01, self.publish_joint_states)  # 100 Hz

    def publish_joint_states(self):
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = ['left_hip', 'left_knee', 'left_ankle',
                    'right_hip', 'right_knee', 'right_ankle']
        msg.position = [0.0, 0.5, -0.3, 0.0, 0.5, -0.3]  # radians
        msg.velocity = [0.0] * 6
        msg.effort = [0.0] * 6
        self.publisher.publish(msg)
```

## Services

### Service Server

```python
from example_interfaces.srv import AddTwoInts

class ServiceServer(Node):
    def __init__(self):
        super().__init__('service_server')
        self.srv = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_two_ints_callback
        )

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'{request.a} + {request.b} = {response.sum}')
        return response
```

### Service Client

```python
from example_interfaces.srv import AddTwoInts

class ServiceClient(Node):
    def __init__(self):
        super().__init__('service_client')
        self.client = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for service...')

    def send_request(self, a, b):
        request = AddTwoInts.Request()
        request.a = a
        request.b = b
        future = self.client.call_async(request)
        return future
```

## Actions

### Action Server

```python
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from action_tutorials_interfaces.action import Fibonacci

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            self.execute_callback
        )

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        # Generate Fibonacci sequence
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.partial_sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            feedback_msg.partial_sequence.append(
                feedback_msg.partial_sequence[i] +
                feedback_msg.partial_sequence[i-1]
            )
            self.get_logger().info(f'Feedback: {feedback_msg.partial_sequence}')
            goal_handle.publish_feedback(feedback_msg)

        goal_handle.succeed()

        result = Fibonacci.Result()
        result.sequence = feedback_msg.partial_sequence
        return result
```

### Action Client

```python
from rclpy.action import ActionClient
from action_tutorials_interfaces.action import Fibonacci

class FibonacciActionClient(Node):
    def __init__(self):
        super().__init__('fibonacci_action_client')
        self._action_client = ActionClient(self, Fibonacci, 'fibonacci')

    def send_goal(self, order):
        goal_msg = Fibonacci.Goal()
        goal_msg.order = order

        self._action_client.wait_for_server()

        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Received feedback: {feedback.partial_sequence}')

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Result: {result.sequence}')
```

## Parameters

### Declaring and Using Parameters

```python
class ParameterNode(Node):
    def __init__(self):
        super().__init__('parameter_node')

        # Declare parameters with default values
        self.declare_parameter('max_speed', 1.0)
        self.declare_parameter('robot_name', 'humanoid_01')
        self.declare_parameter('joint_names', ['joint1', 'joint2'])

        # Get parameter values
        self.max_speed = self.get_parameter('max_speed').value
        self.robot_name = self.get_parameter('robot_name').value
        self.joint_names = self.get_parameter('joint_names').value

        self.get_logger().info(f'Max speed: {self.max_speed}')
        self.get_logger().info(f'Robot name: {self.robot_name}')

        # Add callback for dynamic parameter changes
        self.add_on_set_parameters_callback(self.parameter_callback)

    def parameter_callback(self, params):
        for param in params:
            if param.name == 'max_speed':
                self.max_speed = param.value
                self.get_logger().info(f'Updated max_speed to: {self.max_speed}')
        return SetParametersResult(successful=True)
```

### Loading Parameters from YAML

```yaml
# config/robot_params.yaml
/**:
  ros__parameters:
    max_speed: 2.5
    robot_name: "atlas_v2"
    joint_names: ["left_hip", "right_hip", "left_knee", "right_knee"]
```

```bash
# Launch with parameters
ros2 run my_pkg my_node --ros-args --params-file config/robot_params.yaml
```

## Timers

```python
class TimerNode(Node):
    def __init__(self):
        super().__init__('timer_node')
        self.timer = self.create_timer(0.5, self.timer_callback)  # 2 Hz
        self.count = 0

    def timer_callback(self):
        self.count += 1
        self.get_logger().info(f'Timer callback {self.count}')
```

## Quality of Service (QoS) Profiles

```python
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

# Custom QoS for sensor data
sensor_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=HistoryPolicy.KEEP_LAST,
    depth=1
)

self.publisher = self.create_publisher(Image, '/camera/image', sensor_qos)

# Custom QoS for commands
command_qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)

self.cmd_publisher = self.create_publisher(Twist, '/cmd_vel', command_qos)
```

## Logging

```python
# Different log levels
self.get_logger().debug('Detailed information')
self.get_logger().info('General information')
self.get_logger().warn('Warning message')
self.get_logger().error('Error occurred')
self.get_logger().fatal('Fatal error')

# Throttled logging (max once per second)
self.get_logger().info('High frequency message', throttle_duration_sec=1.0)
```

## Multi-Threading and Executors

```python
from rclpy.executors import MultiThreadedExecutor

# Create nodes
node1 = PublisherNode()
node2 = SubscriberNode()

# Use multi-threaded executor
executor = MultiThreadedExecutor()
executor.add_node(node1)
executor.add_node(node2)

try:
    executor.spin()
finally:
    executor.shutdown()
    node1.destroy_node()
    node2.destroy_node()
    rclpy.shutdown()
```

## Best Practices

### Code Organization
✅ One node class per file
✅ Use `__init__.py` for package imports
✅ Separate logic from ROS communication
✅ Type hints for better code quality

### Error Handling
```python
try:
    response = self.client.call(request)
except Exception as e:
    self.get_logger().error(f'Service call failed: {e}')
```

### Cleanup
```python
def __del__(self):
    self.destroy_node()
```

### Testing
```python
import unittest
from my_robot_pkg.my_node import MyNode

class TestMyNode(unittest.TestCase):
    def test_initialization(self):
        rclpy.init()
        node = MyNode()
        self.assertIsNotNone(node)
        node.destroy_node()
        rclpy.shutdown()
```

## Complete Example: Humanoid Joint Controller

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray

class HumanoidJointController(Node):
    def __init__(self):
        super().__init__('humanoid_joint_controller')

        # Parameters
        self.declare_parameter('control_rate', 100.0)
        self.declare_parameter('joint_names', [])

        self.control_rate = self.get_parameter('control_rate').value
        self.joint_names = self.get_parameter('joint_names').value

        # Publishers
        self.joint_cmd_pub = self.create_publisher(
            Float64MultiArray,
            '/joint_commands',
            10
        )

        # Subscribers
        self.joint_state_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Timer for control loop
        self.timer = self.create_timer(
            1.0 / self.control_rate,
            self.control_loop
        )

        self.current_positions = {}
        self.target_positions = {}

    def joint_state_callback(self, msg):
        for i, name in enumerate(msg.name):
            self.current_positions[name] = msg.position[i]

    def control_loop(self):
        cmd = Float64MultiArray()
        cmd.data = [self.target_positions.get(name, 0.0)
                    for name in self.joint_names]
        self.joint_cmd_pub.publish(cmd)
```

## Summary

You've learned how to use rclpy to:
- Create ROS 2 nodes in Python
- Implement publishers, subscribers, services, and actions
- Use parameters for configuration
- Apply QoS policies for reliable communication
- Handle timing and multi-threading

Next, we'll learn how to model humanoid robots using URDF!

## Next Steps

Continue to [URDF for Humanoids](./urdf-humanoids.mdx) to learn robot modeling.

---

## References

[^1]: Open Robotics. (2022). ROS 2 Client Libraries. *ROS 2 Documentation*. https://docs.ros.org/en/humble/Concepts/About-Different-Middleware-Vendors.html
