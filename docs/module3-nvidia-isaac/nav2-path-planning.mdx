# Navigation & Path Planning with Nav2

Nav2 (Navigation2) is the standard ROS 2 autonomous navigation stack. This section covers architecture, configuration, and integration with Isaac ROS sensors for humanoid robot navigation.

## Nav2 Architecture

Nav2 provides complete autonomous navigation through:

```
┌────────────────────────────────────────────────┐
│              Nav2 Stack                        │
├────────────────────────────────────────────────┤
│  Behavior Tree  →  Controller  →  Planner     │
│  (BT Navigator)    (DWB/TEB)     (NavFn/SMAC)  │
├────────────────────────────────────────────────┤
│           Costmap Layer (2D/3D)                │
│  ┌──────────┬──────────┬──────────┬─────────┐ │
│  │ Static   │ Obstacle │ Inflation │ Voxel  │ │
│  │  Map     │  Layer   │   Layer   │ Layer  │ │
│  └──────────┴──────────┴──────────┴─────────┘ │
├────────────────────────────────────────────────┤
│            Sensor Inputs                       │
│  LiDAR │ Camera │ Depth │ IMU │ Odometry      │
└────────────────────────────────────────────────┘
```

### Core Components

**1. Costmap 2D**: Represents environment obstacles
**2. Planner Server**: Computes global path from start to goal
**3. Controller Server**: Follows path with local obstacle avoidance
**4. Behavior Tree Navigator**: High-level decision making
**5. Recovery Server**: Handles stuck situations
**6. Waypoint Follower**: Navigates through multiple goals
**7. Lifecycle Manager**: Coordinates node startup/shutdown

## Installation

```bash
# Nav2 is included in ROS 2 Humble desktop
sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup

# Verify
ros2 pkg list | grep nav2
```

## Configuration

### 1. Costmap Configuration

Create `config/nav2_params.yaml`:

```yaml
global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: False
      robot_radius: 0.3  # Humanoid footprint radius (meters)
      resolution: 0.05  # 5cm per cell
      track_unknown_space: true

      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True

      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: scan pointcloud

        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "LaserScan"

        pointcloud:
          topic: /camera/depth/points
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "PointCloud2"

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55  # Must be > robot_radius

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 2.0
      global_frame: odom
      robot_base_frame: base_link
      use_sim_time: False
      rolling_window: true
      width: 3  # 3m x 3m local window
      height: 3
      resolution: 0.05
      robot_radius: 0.3
      plugins: ["voxel_layer", "inflation_layer"]

      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: True
        publish_voxel_map: True
        origin_z: 0.0
        z_resolution: 0.05
        z_voxels: 16
        max_obstacle_height: 2.0
        mark_threshold: 0
        observation_sources: pointcloud

        pointcloud:
          topic: /camera/depth/points
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "PointCloud2"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55
```

### 2. Planner Configuration

**NavFn** (Dijkstra's algorithm for global planning):

```yaml
planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: False
    planner_plugins: ["GridBased"]

    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.5
      use_astar: false  # Dijkstra (false) or A* (true)
      allow_unknown: true
```

**SMAC Planner** (State Lattice for non-holonomic robots):

```yaml
    GridBased:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      tolerance: 0.5
      downsample_costmap: false
      downsampling_factor: 1
      allow_unknown: true
      max_iterations: 1000000
      max_planning_time: 5.0
      motion_model_for_search: "DUBIN"  # For differential drive
      angle_quantization_bins: 72
      minimum_turning_radius: 0.4  # Humanoid turning radius
```

### 3. Controller Configuration

**DWB** (Dynamic Window Approach):

```yaml
controller_server:
  ros__parameters:
    use_sim_time: False
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001
    failure_tolerance: 0.3
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"]
    controller_plugins: ["FollowPath"]

    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5
      movement_time_allowance: 10.0

    general_goal_checker:
      stateful: True
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.25
      yaw_goal_tolerance: 0.25

    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      debug_trajectory_details: True
      min_vel_x: 0.0
      min_vel_y: 0.0
      max_vel_x: 0.5  # Humanoid max walking speed
      max_vel_y: 0.0  # Non-holonomic
      max_vel_theta: 1.0
      min_speed_xy: 0.0
      max_speed_xy: 0.5
      min_speed_theta: 0.0
      acc_lim_x: 0.3
      acc_lim_y: 0.0
      acc_lim_theta: 1.0
      decel_lim_x: -0.3
      decel_lim_y: 0.0
      decel_lim_theta: -1.0
      vx_samples: 20
      vy_samples: 5
      vth_samples: 20
      sim_time: 1.7
      linear_granularity: 0.05
      angular_granularity: 0.025
      transform_tolerance: 0.2
      xy_goal_tolerance: 0.25
      trans_stopped_velocity: 0.25
      short_circuit_trajectory_evaluation: True
      stateful: True
      critics: ["RotateToGoal", "Oscillation", "BaseObstacle", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]

      BaseObstacle.scale: 0.02
      PathAlign.scale: 32.0
      PathAlign.forward_point_distance: 0.1
      GoalAlign.scale: 24.0
      GoalAlign.forward_point_distance: 0.1
      PathDist.scale: 32.0
      GoalDist.scale: 24.0
      RotateToGoal.scale: 32.0
      RotateToGoal.slowing_factor: 5.0
      RotateToGoal.lookahead_time: -1.0
```

### 4. Behavior Tree

Configure decision logic:

```yaml
bt_navigator:
  ros__parameters:
    use_sim_time: False
    global_frame: map
    robot_base_frame: base_link
    odom_topic: /odom
    bt_loop_duration: 10
    default_server_timeout: 20
    enable_groot_monitoring: True
    groot_zmq_publisher_port: 1666
    groot_zmq_server_port: 1667

    plugin_lib_names:
    - nav2_compute_path_to_pose_action_bt_node
    - nav2_compute_path_through_poses_action_bt_node
    - nav2_smooth_path_action_bt_node
    - nav2_follow_path_action_bt_node
    - nav2_spin_action_bt_node
    - nav2_wait_action_bt_node
    - nav2_back_up_action_bt_node
    - nav2_drive_on_heading_bt_node
    - nav2_clear_costmap_service_bt_node
    - nav2_is_stuck_condition_bt_node
    - nav2_goal_reached_condition_bt_node
    - nav2_goal_updated_condition_bt_node
    - nav2_globally_updated_goal_condition_bt_node
    - nav2_is_path_valid_condition_bt_node
    - nav2_initial_pose_received_condition_bt_node
    - nav2_reinitialize_global_localization_service_bt_node
    - nav2_rate_controller_bt_node
    - nav2_distance_controller_bt_node
    - nav2_speed_controller_bt_node
    - nav2_truncate_path_action_bt_node
    - nav2_truncate_path_local_action_bt_node
    - nav2_goal_updater_node_bt_node
    - nav2_recovery_node_bt_node
    - nav2_pipeline_sequence_bt_node
    - nav2_round_robin_node_bt_node
    - nav2_transform_available_condition_bt_node
    - nav2_time_expired_condition_bt_node
    - nav2_path_expiring_timer_condition
    - nav2_distance_traveled_condition_bt_node
    - nav2_single_trigger_bt_node
    - nav2_is_battery_low_condition_bt_node
    - nav2_navigate_through_poses_action_bt_node
    - nav2_navigate_to_pose_action_bt_node
    - nav2_remove_passed_goals_action_bt_node
    - nav2_planner_selector_bt_node
    - nav2_controller_selector_bt_node
    - nav2_goal_checker_selector_bt_node
    - nav2_controller_cancel_bt_node
    - nav2_path_longer_on_approach_bt_node
    - nav2_wait_cancel_bt_node
    - nav2_spin_cancel_bt_node
    - nav2_back_up_cancel_bt_node
    - nav2_drive_on_heading_cancel_bt_node
```

## Launch File

Create `launch/navigation.launch.py`:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    pkg_dir = get_package_share_directory('my_humanoid_nav')
    nav2_params = os.path.join(pkg_dir, 'config', 'nav2_params.yaml')

    return LaunchDescription([
        # Map server (if using pre-built map)
        Node(
            package='nav2_map_server',
            executable='map_server',
            name='map_server',
            output='screen',
            parameters=[{
                'yaml_filename': os.path.join(pkg_dir, 'maps', 'office.yaml'),
                'use_sim_time': False
            }]
        ),

        # AMCL localization
        Node(
            package='nav2_amcl',
            executable='amcl',
            name='amcl',
            output='screen',
            parameters=[nav2_params]
        ),

        # Controller server
        Node(
            package='nav2_controller',
            executable='controller_server',
            name='controller_server',
            output='screen',
            parameters=[nav2_params]
        ),

        # Planner server
        Node(
            package='nav2_planner',
            executable='planner_server',
            name='planner_server',
            output='screen',
            parameters=[nav2_params]
        ),

        # Behavior server
        Node(
            package='nav2_behaviors',
            executable='behavior_server',
            name='behavior_server',
            output='screen',
            parameters=[nav2_params]
        ),

        # BT Navigator
        Node(
            package='nav2_bt_navigator',
            executable='bt_navigator',
            name='bt_navigator',
            output='screen',
            parameters=[nav2_params]
        ),

        # Waypoint follower
        Node(
            package='nav2_waypoint_follower',
            executable='waypoint_follower',
            name='waypoint_follower',
            output='screen',
            parameters=[nav2_params]
        ),

        # Lifecycle manager
        Node(
            package='nav2_lifecycle_manager',
            executable='lifecycle_manager',
            name='lifecycle_manager_navigation',
            output='screen',
            parameters=[{
                'use_sim_time': False,
                'autostart': True,
                'node_names': [
                    'map_server',
                    'amcl',
                    'controller_server',
                    'planner_server',
                    'behavior_server',
                    'bt_navigator',
                    'waypoint_follower'
                ]
            }]
        ),
    ])
```

## Integration with Isaac ROS

### Sensor Fusion

Combine Isaac ROS Visual SLAM with Nav2:

```python
# In launch file
Node(
    package='isaac_ros_visual_slam',
    executable='visual_slam_node',
    name='visual_slam',
    parameters=[{
        'denoise_input_images': True,
        'rectified_images': True,
        'enable_imu_fusion': True,
    }],
    remappings=[
        ('/visual_slam/tracking/odometry', '/odom'),  # For Nav2
    ]
),
```

### Depth Camera for Obstacles

Use Isaac ROS stereo output:

```python
Node(
    package='isaac_ros_stereo_image_proc',
    executable='disparity_node',
    name='stereo_proc',
    parameters=[nav2_params],
    remappings=[
        ('/points2', '/camera/depth/points'),  # For costmap
    ]
),
```

## Running Navigation

### 1. Launch Nav2 Stack

```bash
ros2 launch my_humanoid_nav navigation.launch.py
```

### 2. Set Initial Pose

```bash
# Via RViz: 2D Pose Estimate tool

# Or programmatically:
ros2 topic pub --once /initialpose geometry_msgs/PoseWithCovarianceStamped \
  "{header: {frame_id: 'map'}, \
    pose: {pose: {position: {x: 0.0, y: 0.0, z: 0.0}, \
                  orientation: {x: 0.0, y: 0.0, z: 0.0, w: 1.0}}}}"
```

### 3. Send Navigation Goal

**Via RViz**:
- Click "2D Nav Goal"
- Click target position on map

**Via command line**:

```bash
ros2 topic pub --once /goal_pose geometry_msgs/PoseStamped \
  "{header: {frame_id: 'map'}, \
    pose: {position: {x: 5.0, y: 3.0, z: 0.0}, \
          orientation: {x: 0.0, y: 0.0, z: 0.707, w: 0.707}}}"
```

**Via Python action client**:

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped

class NavClient(Node):
    def __init__(self):
        super().__init__('nav_client')
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

    def send_goal(self, x, y, yaw):
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = x
        goal_msg.pose.pose.position.y = y
        goal_msg.pose.pose.orientation.z = yaw

        self._action_client.wait_for_server()
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info('Navigation result: {0}'.format(result))

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Distance remaining: {feedback.distance_remaining:.2f} m')

def main():
    rclpy.init()
    nav_client = NavClient()
    nav_client.send_goal(5.0, 3.0, 0.0)  # Navigate to (5, 3)
    rclpy.spin(nav_client)
```

## Tuning for Humanoids

Humanoids have unique constraints:

### 1. Narrow Footprint

```yaml
# Smaller robot_radius for tight spaces
robot_radius: 0.25  # vs. 0.5 for wheeled robots
inflation_radius: 0.4
```

### 2. Slower Max Velocities

```yaml
# Bipedal walking is slower than wheeled
max_vel_x: 0.3  # 30 cm/s walking
max_vel_theta: 0.5  # Slower turning
```

### 3. Limited Acceleration

```yaml
# Gentle accelerations for stability
acc_lim_x: 0.2
acc_lim_theta: 0.5
decel_lim_x: -0.2
```

### 4. Height Awareness

```yaml
# Use voxel layer for 3D obstacles
voxel_layer:
  z_voxels: 20  # 1m height (0.05m resolution)
  max_obstacle_height: 1.0  # Detect low obstacles
```

## Visualization

```bash
# Launch RViz with Nav2 config
rviz2 -d $(ros2 pkg prefix nav2_bringup)/share/nav2_bringup/rviz/nav2_default_view.rviz
```

**Displays to add**:
- Map (topic: /map)
- Global Costmap (topic: /global_costmap/costmap)
- Local Costmap (topic: /local_costmap/costmap)
- Global Plan (topic: /plan)
- Local Plan (topic: /local_plan)
- RobotModel (TF)
- LaserScan or PointCloud2

## Troubleshooting

### Robot Not Moving

**Check controller active**:
```bash
ros2 lifecycle get /controller_server
# Should be "active"

# If not:
ros2 lifecycle set /controller_server configure
ros2 lifecycle set /controller_server activate
```

### Path Not Generated

**Check planner**:
```bash
ros2 topic echo /plan
# Should show path when goal sent

# Debug:
ros2 param get /planner_server GridBased.allow_unknown
```

### Costmap Shows No Obstacles

**Verify sensor data**:
```bash
ros2 topic hz /scan
ros2 topic hz /camera/depth/points

# Check costmap subscriptions:
ros2 topic info /scan
```

## Summary

Nav2 provides:

✅ **Costmap 2D/3D** for environment representation
✅ **Global planner** for long-range paths
✅ **Local controller** for obstacle avoidance
✅ **Behavior trees** for high-level logic
✅ **Recovery behaviors** for stuck situations
✅ **Isaac ROS integration** for GPU-accelerated sensors

Next, learn reinforcement learning for training walking gaits!

## Next Steps

Continue to [Reinforcement Learning Basics](./rl-robot-control.mdx) to train robot behaviors.

---

## References

[^1]: Macenski, S., Martín, F., White, R., & Ginés Clavero, J. (2020). The Marathon 2: A Navigation System. *IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)*, 2718-2725.

[^2]: Fox, D., Burgard, W., & Thrun, S. (1997). The Dynamic Window Approach to Collision Avoidance. *IEEE Robotics & Automation Magazine*, 4(1), 23-33.

[^3]: Dolgov, D., et al. (2010). Path Planning for Autonomous Vehicles in Unknown Semi-structured Environments. *The International Journal of Robotics Research*, 29(5), 485-501.

[^4]: Pivtoraiko, M., & Kelly, A. (2005). Generating Near Minimal Spanning Control Sets for Constrained Motion Planning in Discrete State Spaces. *IROS 2005*, 3231-3237.
