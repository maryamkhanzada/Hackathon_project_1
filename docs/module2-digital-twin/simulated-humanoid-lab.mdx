# Simulated Humanoid Lab

This hands-on lab integrates all Module 2 concepts to create a complete simulated humanoid robot in Gazebo. You'll build a digital twin with sensors, configure physics, and test basic locomotion.

## Lab Overview

**Objectives**:
- Import a humanoid URDF into Gazebo
- Add cameras, IMU, and force/torque sensors
- Configure collision and dynamics properties
- Create a test environment world
- Implement basic joint control
- Validate simulation accuracy

**Time**: 2-3 hours

**Prerequisites**:
- Completed Module 1 (ROS 2 basics, URDF)
- Gazebo Garden installed
- ROS 2 Humble workspace set up

## Part 1: Project Setup

### Create ROS 2 Package

```bash
# Navigate to workspace
cd ~/ros2_ws/src

# Create package for humanoid simulation
ros2 pkg create humanoid_sim \
  --build-type ament_cmake \
  --dependencies rclcpp rclpy sensor_msgs geometry_msgs std_msgs \
  --node-name humanoid_controller

# Create directory structure
cd humanoid_sim
mkdir -p urdf meshes launch worlds config
```

### Download Base Humanoid Model

For this lab, we'll use a simplified humanoid URDF:

```bash
# Create simplified humanoid URDF
cat > urdf/humanoid.urdf << 'EOF'
<?xml version="1.0"?>
<robot name="simple_humanoid">
  <!-- Base link (root) -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.001 0.001 0.001"/>
      </geometry>
    </visual>
  </link>

  <!-- Torso -->
  <link name="torso">
    <inertial>
      <mass value="20.0"/>
      <origin xyz="0 0 0.25"/>
      <inertia ixx="0.67" ixy="0" ixz="0"
               iyy="0.53" iyz="0" izz="0.33"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0.25"/>
      <geometry>
        <box size="0.3 0.2 0.5"/>
      </geometry>
      <material name="torso_color">
        <color rgba="0.8 0.8 0.8 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0.25"/>
      <geometry>
        <box size="0.3 0.2 0.5"/>
      </geometry>
    </collision>
  </link>

  <joint name="base_to_torso" type="fixed">
    <parent link="base_link"/>
    <child link="torso"/>
  </joint>

  <!-- Head -->
  <link name="head">
    <inertial>
      <mass value="2.5"/>
      <inertia ixx="0.01" ixy="0" ixz="0"
               iyy="0.01" iyz="0" izz="0.01"/>
    </inertial>
    <visual>
      <geometry>
        <sphere radius="0.12"/>
      </geometry>
      <material name="head_color">
        <color rgba="0.9 0.85 0.8 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <sphere radius="0.12"/>
      </geometry>
    </collision>
  </link>

  <joint name="neck" type="revolute">
    <parent link="torso"/>
    <child link="head"/>
    <origin xyz="0 0 0.56" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <limit lower="-0.785" upper="0.785" effort="10.0" velocity="1.0"/>
    <dynamics damping="0.5" friction="0.2"/>
  </joint>

  <!-- Left Leg -->
  <link name="left_thigh">
    <inertial>
      <mass value="4.0"/>
      <origin xyz="0 0 -0.2"/>
      <inertia ixx="0.053" ixy="0" ixz="0"
               iyy="0.053" iyz="0" izz="0.0064"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.2"/>
      <geometry>
        <capsule radius="0.06" length="0.4"/>
      </geometry>
      <material name="leg_color">
        <color rgba="0.3 0.3 0.3 1.0"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 -0.2"/>
      <geometry>
        <capsule radius="0.06" length="0.4"/>
      </geometry>
    </collision>
  </link>

  <joint name="left_hip" type="revolute">
    <parent link="torso"/>
    <child link="left_thigh"/>
    <origin xyz="0 0.1 0" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <limit lower="-1.57" upper="1.57" effort="150.0" velocity="3.0"/>
    <dynamics damping="2.0" friction="1.0"/>
  </joint>

  <link name="left_shin">
    <inertial>
      <mass value="2.5"/>
      <origin xyz="0 0 -0.175"/>
      <inertia ixx="0.031" ixy="0" ixz="0"
               iyy="0.031" iyz="0" izz="0.0036"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.175"/>
      <geometry>
        <capsule radius="0.05" length="0.35"/>
      </geometry>
      <material name="leg_color"/>
    </visual>
    <collision>
      <origin xyz="0 0 -0.175"/>
      <geometry>
        <capsule radius="0.05" length="0.35"/>
      </geometry>
    </collision>
  </link>

  <joint name="left_knee" type="revolute">
    <parent link="left_thigh"/>
    <child link="left_shin"/>
    <origin xyz="0 0 -0.4" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <limit lower="0.0" upper="2.35" effort="100.0" velocity="3.0"/>
    <dynamics damping="1.5" friction="0.8"/>
  </joint>

  <link name="left_foot">
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.002" ixy="0" ixz="0"
               iyy="0.005" iyz="0" izz="0.004"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.2 0.1 0.05"/>
      </geometry>
      <material name="foot_color">
        <color rgba="0.2 0.2 0.2 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.2 0.1 0.05"/>
      </geometry>
    </collision>
  </link>

  <joint name="left_ankle" type="revolute">
    <parent link="left_shin"/>
    <child link="left_foot"/>
    <origin xyz="0 0 -0.35" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <limit lower="-0.785" upper="0.785" effort="50.0" velocity="2.0"/>
    <dynamics damping="0.8" friction="0.5"/>
  </joint>

  <!-- Right Leg (mirror of left) -->
  <link name="right_thigh">
    <inertial>
      <mass value="4.0"/>
      <origin xyz="0 0 -0.2"/>
      <inertia ixx="0.053" ixy="0" ixz="0"
               iyy="0.053" iyz="0" izz="0.0064"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.2"/>
      <geometry>
        <capsule radius="0.06" length="0.4"/>
      </geometry>
      <material name="leg_color"/>
    </visual>
    <collision>
      <origin xyz="0 0 -0.2"/>
      <geometry>
        <capsule radius="0.06" length="0.4"/>
      </geometry>
    </collision>
  </link>

  <joint name="right_hip" type="revolute">
    <parent link="torso"/>
    <child link="right_thigh"/>
    <origin xyz="0 -0.1 0" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <limit lower="-1.57" upper="1.57" effort="150.0" velocity="3.0"/>
    <dynamics damping="2.0" friction="1.0"/>
  </joint>

  <link name="right_shin">
    <inertial>
      <mass value="2.5"/>
      <origin xyz="0 0 -0.175"/>
      <inertia ixx="0.031" ixy="0" ixz="0"
               iyy="0.031" iyz="0" izz="0.0036"/>
    </inertial>
    <visual>
      <origin xyz="0 0 -0.175"/>
      <geometry>
        <capsule radius="0.05" length="0.35"/>
      </geometry>
      <material name="leg_color"/>
    </visual>
    <collision>
      <origin xyz="0 0 -0.175"/>
      <geometry>
        <capsule radius="0.05" length="0.35"/>
      </geometry>
    </collision>
  </link>

  <joint name="right_knee" type="revolute">
    <parent link="right_thigh"/>
    <child link="right_shin"/>
    <origin xyz="0 0 -0.4" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <limit lower="0.0" upper="2.35" effort="100.0" velocity="3.0"/>
    <dynamics damping="1.5" friction="0.8"/>
  </joint>

  <link name="right_foot">
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.002" ixy="0" ixz="0"
               iyy="0.005" iyz="0" izz="0.004"/>
    </inertial>
    <visual>
      <geometry>
        <box size="0.2 0.1 0.05"/>
      </geometry>
      <material name="foot_color"/>
    </visual>
    <collision>
      <geometry>
        <box size="0.2 0.1 0.05"/>
      </geometry>
    </collision>
  </link>

  <joint name="right_ankle" type="revolute">
    <parent link="right_shin"/>
    <child link="right_foot"/>
    <origin xyz="0 0 -0.35" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <limit lower="-0.785" upper="0.785" effort="50.0" velocity="2.0"/>
    <dynamics damping="0.8" friction="0.5"/>
  </joint>
</robot>
EOF
```

## Part 2: Adding Sensors

### Create Sensor-Equipped URDF

Create `urdf/humanoid_with_sensors.urdf.xacro`:

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_sensors">

  <!-- Include base humanoid -->
  <xacro:include filename="$(find humanoid_sim)/urdf/humanoid.urdf"/>

  <!-- Camera on head -->
  <link name="camera_link">
    <visual>
      <origin xyz="0 0 0"/>
      <geometry>
        <box size="0.02 0.05 0.02"/>
      </geometry>
      <material name="camera_color">
        <color rgba="0.1 0.1 0.1 1.0"/>
      </material>
    </visual>
  </link>

  <joint name="camera_joint" type="fixed">
    <parent link="head"/>
    <child link="camera_link"/>
    <origin xyz="0.12 0 0" rpy="0 0 0"/>
  </joint>

  <!-- Gazebo camera sensor -->
  <gazebo reference="camera_link">
    <sensor name="head_camera" type="camera">
      <camera>
        <image>
          <width>640</width>
          <height>480</height>
          <format>R8G8B8</format>
        </image>
        <horizontal_fov>1.047</horizontal_fov>  <!-- 60 degrees -->
        <clip>
          <near>0.1</near>
          <far>100.0</far>
        </clip>
        <noise>
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>0.007</stddev>
        </noise>
      </camera>
      <update_rate>30</update_rate>
      <plugin filename="libgazebo_ros_camera.so" name="camera_controller">
        <ros>
          <namespace>/humanoid</namespace>
          <remapping>~/image_raw:=camera/image_raw</remapping>
        </ros>
        <frame_name>camera_link</frame_name>
      </plugin>
    </sensor>
  </gazebo>

  <!-- IMU in torso -->
  <link name="imu_link"/>

  <joint name="imu_joint" type="fixed">
    <parent link="torso"/>
    <child link="imu_link"/>
    <origin xyz="0 0 0.25" rpy="0 0 0"/>
  </joint>

  <gazebo reference="imu_link">
    <sensor name="torso_imu" type="imu">
      <imu>
        <angular_velocity>
          <x><noise type="gaussian"><stddev>0.001</stddev></noise></x>
          <y><noise type="gaussian"><stddev>0.001</stddev></noise></y>
          <z><noise type="gaussian"><stddev>0.001</stddev></noise></z>
        </angular_velocity>
        <linear_acceleration>
          <x><noise type="gaussian"><stddev>0.01</stddev></noise></x>
          <y><noise type="gaussian"><stddev>0.01</stddev></noise></y>
          <z><noise type="gaussian"><stddev>0.01</stddev></noise></z>
        </linear_acceleration>
      </imu>
      <update_rate>100</update_rate>
      <plugin filename="libgazebo_ros_imu_sensor.so" name="imu_plugin">
        <ros>
          <namespace>/humanoid</namespace>
          <remapping>~/out:=imu/data</remapping>
        </ros>
        <frame_name>imu_link</frame_name>
      </plugin>
    </sensor>
  </gazebo>

  <!-- Force/Torque sensor in left foot -->
  <gazebo reference="left_ankle">
    <sensor name="left_foot_ft" type="force_torque">
      <force_torque>
        <frame>child</frame>
        <measure_direction>child_to_parent</measure_direction>
      </force_torque>
      <update_rate>100</update_rate>
      <plugin filename="libgazebo_ros_ft_sensor.so" name="left_ft_sensor">
        <ros>
          <namespace>/humanoid</namespace>
          <remapping>~/out:=left_foot/force_torque</remapping>
        </ros>
      </plugin>
    </sensor>
  </gazebo>

  <!-- Right foot FT sensor -->
  <gazebo reference="right_ankle">
    <sensor name="right_foot_ft" type="force_torque">
      <force_torque>
        <frame>child</frame>
        <measure_direction>child_to_parent</measure_direction>
      </force_torque>
      <update_rate>100</update_rate>
      <plugin filename="libgazebo_ros_ft_sensor.so" name="right_ft_sensor">
        <ros>
          <namespace>/humanoid</namespace>
          <remapping>~/out:=right_foot/force_torque</remapping>
        </ros>
      </plugin>
    </sensor>
  </gazebo>

  <!-- Contact surfaces for feet (high friction) -->
  <gazebo reference="left_foot">
    <surface>
      <friction>
        <ode>
          <mu>0.9</mu>
          <mu2>0.9</mu2>
        </ode>
      </friction>
      <contact>
        <ode>
          <kp>10000000.0</kp>
          <kd>1000.0</kd>
        </ode>
      </contact>
    </surface>
  </gazebo>

  <gazebo reference="right_foot">
    <surface>
      <friction>
        <ode>
          <mu>0.9</mu>
          <mu2>0.9</mu2>
        </ode>
      </friction>
      <contact>
        <ode>
          <kp>10000000.0</kp>
          <kd>1000.0</kd>
        </ode>
      </contact>
    </surface>
  </gazebo>

</robot>
```

## Part 3: Gazebo World

Create a test environment with obstacles:

```bash
cat > worlds/humanoid_test.world << 'EOF'
<?xml version="1.0"?>
<sdf version="1.8">
  <world name="humanoid_world">
    <!-- Physics -->
    <physics name="default_physics" type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
    </physics>

    <!-- Lighting -->
    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>1.0 1.0 1.0 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <direction>-0.5 0.5 -1.0</direction>
    </light>

    <!-- Ground plane -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.8</mu>
                <mu2>0.8</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- Test obstacle (box) -->
    <model name="obstacle_box">
      <pose>2.0 0 0.25 0 0 0</pose>
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box><size>0.5 0.5 0.5</size></box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box><size>0.5 0.5 0.5</size></box>
          </geometry>
          <material>
            <ambient>1.0 0.5 0.0 1</ambient>
            <diffuse>1.0 0.5 0.0 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

  </world>
</sdf>
EOF
```

## Part 4: Joint Controller

Create a simple joint position controller:

```python
# Save as scripts/joint_controller.py
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64MultiArray
from sensor_msgs.msg import JointState
import math

class HumanoidJointController(Node):
    def __init__(self):
        super().__init__('humanoid_joint_controller')

        # Publishers
        self.joint_cmd_pub = self.create_publisher(
            Float64MultiArray,
            '/humanoid/joint_commands',
            10
        )

        # Subscribers
        self.joint_state_sub = self.create_subscription(
            JointState,
            '/humanoid/joint_states',
            self.joint_state_callback,
            10
        )

        # Timer for control loop (10 Hz)
        self.timer = self.create_timer(0.1, self.control_loop)

        # Joint names
        self.joint_names = [
            'neck',
            'left_hip', 'left_knee', 'left_ankle',
            'right_hip', 'right_knee', 'right_ankle'
        ]

        # Current joint states
        self.current_positions = [0.0] * len(self.joint_names)

        # Simple squat motion
        self.time = 0.0

        self.get_logger().info('Humanoid joint controller started')

    def joint_state_callback(self, msg):
        # Update current joint positions
        for i, name in enumerate(self.joint_names):
            if name in msg.name:
                idx = msg.name.index(name)
                self.current_positions[i] = msg.position[idx]

    def control_loop(self):
        self.time += 0.1

        # Generate simple squat motion
        squat_angle = 0.5 * math.sin(self.time)  # 0 to 0.5 rad

        # Desired positions
        desired_positions = [
            0.0,  # neck (stationary)
            0.0,  # left_hip
            squat_angle,  # left_knee (bend)
            0.0,  # left_ankle
            0.0,  # right_hip
            squat_angle,  # right_knee (bend)
            0.0   # right_ankle
        ]

        # Publish commands
        msg = Float64MultiArray()
        msg.data = desired_positions
        self.joint_cmd_pub.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    controller = HumanoidJointController()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Make executable:
```bash
chmod +x scripts/joint_controller.py
```

## Part 5: Launch File

Create launch file to start everything:

```python
# Save as launch/humanoid_sim.launch.py
import os
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    pkg_share = get_package_share_directory('humanoid_sim')

    # Paths
    urdf_file = os.path.join(pkg_share, 'urdf', 'humanoid_with_sensors.urdf.xacro')
    world_file = os.path.join(pkg_share, 'worlds', 'humanoid_test.world')

    # Gazebo launch
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            os.path.join(get_package_share_directory('gazebo_ros'), 'launch', 'gazebo.launch.py')
        ]),
        launch_arguments={'world': world_file}.items()
    )

    # Spawn robot
    spawn_robot = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=['-entity', 'humanoid',
                   '-file', urdf_file,
                   '-x', '0', '-y', '0', '-z', '1.0'],
        output='screen'
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': open(urdf_file).read()}]
    )

    # Joint controller
    joint_controller = Node(
        package='humanoid_sim',
        executable='joint_controller.py',
        output='screen'
    )

    return LaunchDescription([
        gazebo,
        spawn_robot,
        robot_state_publisher,
        joint_controller
    ])
```

## Part 6: Build and Test

### Build Package

```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_sim
source install/setup.bash
```

### Launch Simulation

```bash
ros2 launch humanoid_sim humanoid_sim.launch.py
```

You should see:
- Gazebo GUI with humanoid robot standing
- Robot performing slow squat motion
- Console showing no errors

### Verify Sensors

In separate terminals:

```bash
# Check camera images
ros2 topic hz /humanoid/camera/image_raw
# Should output: ~30 Hz

# Check IMU data
ros2 topic echo /humanoid/imu/data
# Should show orientation, angular velocity, linear acceleration

# Check foot force/torque
ros2 topic echo /humanoid/left_foot/force_torque
# Should show force in Z (gravity) when foot on ground

# Visualize in RViz
rviz2
# Add: Image display (topic: /humanoid/camera/image_raw)
#      RobotModel (topic: /robot_description)
#      TF
```

## Part 7: Validation Tests

### Test 1: Static Balance

Verify robot doesn't fall when stationary:

```python
# Stop joint controller (Ctrl+C)
# Robot should remain standing for 10+ seconds
# Check foot forces are stable (~150 N each, total ~300 N for 30kg robot)
```

### Test 2: Sensor Data Quality

```bash
# Record sensor data
ros2 bag record /humanoid/camera/image_raw /humanoid/imu/data

# Play back and analyze
ros2 bag play <bag_file>

# Check IMU noise levels match specification (σ ≈ 0.01 m/s²)
```

### Test 3: Contact Detection

```python
# Monitor foot force/torque sensors
ros2 topic echo /humanoid/left_foot/force_torque

# When robot squats:
# - Force Z should vary (higher when compressed)
# - Force X/Y should be small (under 10 N)
```

## Part 8: Troubleshooting

### Robot Falls Through Floor

**Fix**: Increase contact stiffness in URDF:
```xml
<kp>20000000.0</kp>  <!-- Double the stiffness -->
```

### Joint Control Not Working

**Check**:
```bash
# Verify joint state publisher running
ros2 topic list | grep joint_states

# Check command topic
ros2 topic echo /humanoid/joint_commands
```

### Camera Not Publishing

**Fix**: Verify Gazebo camera plugin loaded:
```bash
# Check for plugin errors in Gazebo terminal
# Reinstall if needed:
sudo apt install ros-humble-gazebo-ros-pkgs
```

## Summary

You've created a complete simulated humanoid with:

✅ **URDF Model**: 7-DOF bipedal robot with realistic mass/inertia
✅ **Sensors**: RGB camera, IMU, force/torque sensors
✅ **Physics**: Configured friction, contact dynamics, joint limits
✅ **Control**: Basic joint position controller
✅ **Validation**: Verified sensor data and stability

This digital twin foundation enables advanced control development in future modules!

## Next Steps

**Extend This Lab**:
1. Add arms with grippers
2. Implement walking gait controller
3. Add LiDAR for navigation
4. Create more complex test environments
5. Integrate with Module 3 perception stack

Continue to **Module 3: Perception & Computer Vision** to process the camera and sensor data from your simulated robot!

---

## References

[^1]: Siciliano, B., & Khatib, O. (Eds.). (2016). *Springer Handbook of Robotics*. Springer. ISBN: 978-3-319-32552-1.

[^2]: Kajita, S., et al. (2014). *Introduction to Humanoid Robotics*. Springer. ISBN: 978-3-642-54535-3.

[^3]: Open Robotics. (2024). Gazebo Tutorials. https://gazebosim.org/docs/garden/tutorials
